---
title: "Introdução ao R para Análise de Dados"
subtitle: "Minicurso"
author: "Paulo Alexandrino"
header-includes:
   - \usepackage[brazil]{babel}
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    latex_engine: xelatex
date: "Março 2023"
documentclass: "report"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Carregando pacotes necessários
library(tidyverse)
library(gapminder)
library(formatR)

set.seed(42)

# Carregando arquivos necessários
gapminderCountries <- gapminder %>%
  filter(country %in% c("Brazil", "Botswana", "Korea, Rep."))

gapminder2007 <- gapminder %>%
  filter(year == 2007)
```

# Conceitos Fundamentais

## Operadores

### Operadores matemáticos

A forma mais elementar de utilizar o R é como uma calculadora que nos permite realizar todo tipo de operação matemática desejada.

```{r}
# Soma (+)
5 + 7

# Subtração (-)
10 - 16

# Multiplicação (*)
2 * 7

# Exponenciação (^)
2^4

# Divisão (/)
5 / 2

# Divisão Inteira (%/%)
5 %/% 2

# Módulo - Resto da divisão inteira (%%)
5 %% 2
```

### Operadores lógicos

Operadores lógicos nos permitem estabelecer relações entre objetos e julgar proposições (orações declarativas) como verdadeiras (`TRUE`) ou falsas (`FALSE`). Serão muito úteis a construção de filtros.

```{R}
# Menor que (<)
5 < 3

# Menor ou igual que (<=)
2.5 <= 7

# Maior que (>)
10 > 15

# Maior ou igual que (>=)
11 >= 11

# Igual a (==)
2 == 3

# Diferente de (!=)
5 != 4
```

A negação de uma proposição é seu inverso lógico.

```{r}
# Negação (!)
2 > 5
!(2 > 5)
```

Os conectivos de conjunção ($\wedge$, lê-se `E`) e disjunção ($\vee$, lê-se `OU`) são operadores lógicos que permitem criar proposições compostas. Sejam $p$ e $q$ proposições quaisquer:

* A conjunção $p \wedge q$ é verdadeira se $p$ e $q$ são ambas verdadeiras; se ao menos uma delas for falsa, $p \wedge q$ é falsa.

```{r, echo=FALSE}
conectivoE <- data.frame(
  p = c("V","V","F","F"),
  q = c("V","F","V","F"),
  pEq = c("V","F","F","F")
)

colnames(conectivoE) <- c("p","q","p ^ q")

knitr::kable(conectivoE)
```

```{r}
# E (&)
(2 > 1) & (3 != 0)
(3 < 2) & (5 < 11)
```

* A disjunção $p \vee q$ é verdadeira se $p$ e $q$ se ao menos uma das proposições $p$ ou $q$ é verdadeira; se $p$ e $q$ são ambas falsas, então $p \vee q$ é falsa.

```{r, echo=FALSE}
conectivoOU <- data.frame(
  p = c("V","V","F","F"),
  q = c("V","F","V","F"),
  pOUq = c("V","V","V","F")
)

colnames(conectivoOU) <- c("p","q","p V q")

knitr::kable(conectivoOU)
```

```{r}
# OU (|)
(3 < 2) | (5 < 11)
(5 == 6) | (12 < 8)
```

## Objetos, Tipos de Dados e Variáveis

Em R praticamente tudo é um objeto: um número, uma palavra, um vetor contendo diversos números, uma tabela contendo diferentes vetores, uma lista contendo várias tabelas...as coisas podem ficar tão complicadas quanto se queira. 

### Vetores

Vetores são objetos formados por dados de um mesmo tipo. Um vetor pode conter nenhum, um ou mais valores. Alguns dos principais tipos de dados são:

* `logical`: `TRUE` ou `FALSE`
* `integer`: números inteiros
* `numeric` ou `double`: números reais
* `character`: texto

```{r}
# Para atribuir um valor a uma variável utilizados "<-" ou então "=".
# Não confundiro o = de atribuição com o == operador lógico.
# Vetores podem ser criados, ou concatenados como veremos mais adiante,
# utilizando a função c().

# Criando a variável vetor_vazio e deixando ela vazia
vetor_vazio <- c()
# Imprimindo a variável vetor_vazio
vetor_vazio

# Podemos atribuir apenas um valor a uma variável
var_texto <- "Palavra"
var_texto

# Podemos atribuir qualquer valor a uma variável
var_numerica <- 3*(5 + 2)
var_numerica

# Criando um vetores com três valores
var_texto <- c("Palavra","Word","Mot")
var_texto

# Criando um vetor lógico
var_logico = c(3 + 4 < 5, 2 == 1 + 1)
var_logico
```

### Data frames

Podemos agrupar vetores em um data frame. Em R, data frames são tabelas bidimensionais, semelhantes às planilhas do Excel. Este tipo de objeto será o mais utilizado em nosso dia-a-dia. 

Vamos construir um data frame dos estados da região sudeste do Brasil, com as informações de nome, sigla, nome da capital, código DDD da capital e se a capital possui acesso para o mar.

```{r}
# Criando um data frame:
estados_sudeste <- data.frame(
  estado = c("Rio de Janeiro", "Sao Paulo", "Minas Gerais","Espirito Santo"),
  sigla = c("RJ", "SP", "MG", "ES"),
  capital = c("Rio de Janeiro", "Sao Paulo", "Belo Horizonte", "Vitoria"),
  DDD_capital = c(21, 11, 31, 27),
  mar_na_capital = c(TRUE, FALSE, FALSE, TRUE)
)

estados_sudeste
```
Esse procedimento funciona para data frames pequenos, mas não é difícil notar que se torna uma tarefa trabalhosa conforme aumenta-se o número de observações e variáveis. Felizmente, o R permite importar dados de outras fontes, o que aprenderemos a fazer em breve.

## Funções

Funções são ferramentas, porções de código reutilizáveis. Elas nos permitem realizar os mais variados tipos de operações, seja criar ou modificar objetos, realizar comandos no computador, e muito mais. 

Funções quase sempre recebem argumentos, de forma a ajustar seu comportamento de acordo com algum objetivo específico. Alguns argumentos são obrigatórios, outros opicionais, ou seja, possuem valores pré-definidos.

Caso queira obter mais informações sobre uma função, você pode acessar sua documentação. A documentação contém tudo, ou a maior parte, do que se precisa saber sore uma função: quais seus argumentos, como eles se comportam, quais os valores pré-definidos. Para acessar a documentação basta digitar um ponto de interrogação seguido do nome da função.

Para aprendermos a usar algumas funções essenciais, usaremos o dataset `USArrests`, que contém dados sobre criminalidade nos 50 estados dos EUA no ano de 1973, e já vem pré-carregado no R. Assim, não precisaremos importar nada.

### Explorando os dados

```{r}
# Vendo a estrutura dos dados:
str(USArrests)

# Vendo um resumo dos dados:
summary(USArrests)

# Vendo as primeiras observações:
head(USArrests)

# Vendo as últimas observações:
tail(USArrests)

# Número de linhas:
nrow(USArrests)

# Número de colunas:
ncol(USArrests)
```

Como vimos anteriormente, um `data frame` é uma representação tabular, onde cada linha corresponde a uma observação e cada coluna uma variável, ou atributo. Para obtermos uma coluna específica de um `data frame`, podemos utilizar o símbolo `$`.

```{r}
# Selecionando apenas a coluna Murder:
USArrests$Murder

# Classe de um objeto:
class(USArrests$Murder)

# Mínimo:
min(USArrests$Murder)

# Máximo:
max(USArrests$Murder)

# Somatório:
sum(USArrests$Murder)

# Comprimento de um vetor:
length(USArrests$Murder)

# Ordenar um vetor em ordem crescente:
sort(USArrests$Murder)

# A função sort possui o argumento opcional decreasing = FALSE. 
# Para ordenar a lista de forma decrescente, podemos alterá-lo.
sort(USArrests$Murder, decreasing = TRUE)
```

### Estatísticas Descritivas

Vamos usar agora outras colunas para calcularmos estatísticas descritivas utilizando funções do R.

```{r}
# Média:
mean(USArrests$Assault)

# Mediana:
median(USArrests$Assault)

# Quantis:
quantile(USArrests$Assault)

# Variância:
var(USArrests$Assault)

# Desvio padrão:
sd(USArrests$Assault)

# Covariância: 
cov(USArrests$Assault, USArrests$Murder)

# Correlação:
cor(USArrests$Assault, USArrests$Murder)
```

Ao resultado de uma função pode ser aplicada outra função, o que é chamado de aninhamento. Vamos supor, por exemplo que queiremos arredondar, com três casas decimais, o valor calculado para a correlação entre as variáveis `Assault` e `Murder`.

```{r}
# A função utilizada para arredondar um número é round().
# Para que tenha 2 casa decimais, precisaremos ajustar o parâmetro digits.
round(cor(USArrests$Assault, USArrests$Murder), digits = 3)
```

### Criação de vetores

Vamos conhecer algumas funções que podem ser usadas para criar vetores numéricos de forma fácil. 

```{r}
# Criar um vetor de com o valor x repetido n vezes:
rep(2, 3)

# Criar uma sequencia de números: seq()
seq(from = 1, to = 50, by = 3)

# Podemos substituir, por exemplo seq(from = x, to = y, by = 1)
3:15

# Vamos atribuir os valores anteriormente encontrados a variáveis:
var1 <- rep(2, 3)
var2 <- seq(from = 1, to = 50, by = 3)

# Para concatenar vetores, utilizamos a função c()
meu_vetor <- c(var1, var2)
meu_vetor
```

### Amostragem

O R foi uma linguagem criada por estatísticos e até hoje possui como um de seus pontos fortes sua capacidade de lidar com amostragem e simulações. 

```{r}
# Permutação aleatórias dos números naturais menores que 7:
sample(7)

# Permutação aleatória dos números entre 2 e 5:
sample(2:5)

# Sorteio, sem reposição, de 5 números aleatórios 
# da variável var2 que criamos anteriormente:
sample(var2, 5)

# Sorteio, com reposição, de 6 números aleatórios entre 1 e 4:
sample(1:4, size = 6, replace = TRUE)

# Sorteio, sem reposição, de uma palavra em uma lista:
sample(c("pera", "uva", "banana", "caqui"), 1)
```

## Baixando e excutando pacotes externos

Até agora utilizamos apenas funções pré-instaladas no R. Para ter acesso a novos pacotes, será necessário instalá-los primeiro. Esse procedimento só é necessário ser feito uma vez, a não ser que o R precise ser reinstalado. Sempre que iniciar uma sessão será necessário carregar os pacotes que serão utilizados.

```{r, eval=FALSE}
# Instalando o tidyverse
install.packages("tidyverse")

# Carregando o tidyverse
library("tidyverse")
```

O `tidyverse` é um conjunto de pacotes que juntos fornecem uma ampla gama de ferramentas para análise de dados. Algumas dessas ferramentas apresentam versões otimizadas de funções já existentes no R.

O operador pipe (`%>%`) permite substituir o aninhamento de funções por uma cadeia de operação, o que torna os códigos mais legíveis. Veremos aplicações do pipe e de algumas dos principais pacotes e funções do `tidyverse` nos capítulos posteriores.


# Importação

O R nos permite importar e utilizar em nossas análises uma série de diferentes tipos de arquivos. Isso pode ser feito por meio de funções nativas ou através de ferramentas disponíveis em pacotes criados por outros usuários. Por exemplo, o `tidyverse` possui os pacotes `readr`, que permite a leitura de arquivos como .csv, .fwf e .txt, e o pacote `readxl`, para leitura de arquivos Excel. 

## Arquivos separados por vírgula (.csv)

*Comma-separated values* é um formato de arquivo de texto onde as observações de uma tabela são representadas por linhas e as colunas são separadas por vírgula (no padrão americano) ou ponto-e-vírgula (no padrão europeu e brasileiro). No padrão separado por vírgula, o indicador decimal é o ponto; no padrãos separado por ponto-e-vírgula, a vírcula. É importante estar atento ao tipo de arquivo que estamos lidando.

O dataset `gapminder` contém dados econômicos e demográficos para diversos países a cada 5 anos de 1952 a 2007. O arquivo que usaremos como exemplo apresenta uma amostra contendo as informações disponíveis para o Brasil, Botsuana e Coréia do Sul. Ele foi salvo em .csv com padrão separado por ponto-e-vírgula.

```{r}
# Primeira forma: ajustando os parâmetros da função read.csv
gapminderCountries <- read.csv("Aula1/gapminderCountries.csv",
                               sep = ";",
                               dec = ",")

# Segunda forma: utilizando a função read.csv2
gapminderCountries <- read.csv2("Aula1/gapminderCountries.csv")

# Mostrando um pedaço do dataset
head(gapminderCountries)
```

Para maiores informações, leia a documentação das funções `read.csv` e `read.csv2`.

## Arquivos Excel (.xls e .xlsx)

O Microsoft Excel é um dos *softwares* de planilha mais populares do mundo. São muito utilizados não só no meio corporativo, mas também no meio acadêmico. Apesar de limitações principalmente relacionadas a lidar com datas e tabelas muito grandes, é uma ferramenta poderosa e torna-se ainda melhor se aliada ao R. 

O `tidyverse` não carrega automaticamente o pacote necessário para ler arquivos Excel, portanto, precisaremos carregar o `readxl`. Utilizaremos como exemplo uma amostra do dataset `gapminder`, mas desta vez contendo informações para todos os países no ano de 2007. 

```{r}
# Carregando o pacote necessário
library(readxl)

# Importando o arquivo de interesse
gapminder2007 <- read_excel("Aula1/gapminder2007.xlsx")

# Mostrando um pedaço do dataset
head(gapminder2007)
```

# Visualização

A visualização pode ser utilizada tanto para conhecer os dados com que iremos trabalhar, quanto para comunicar com ao público aquilo que descobrimos. Para tanto, o `tidyverse` fornece o pacote `ggplot2`, uma ferramenta poderossíma! 

Ele permite construir desde gráficos simples até visualizações extremamente elaboradas, onde diversas variáveis são mapeadas em diferentes atributos de um gráfico. Somado a outras ferramentas, o `ggplot2` também pode ser utilizado para a construção de mapas.

## Gráfico de linha

Gráficos de linhas são muito utilizados para mostrar tendências ao longo do tempo. Utilizando o dataset `gapminderCountries` que contruímos anteriormente, poderemos ver de que forma o PIB per capita de Brasil, Botsuana e Coreia do Sul se comportaram ao longo do tempo.

```{r}
gapminderCountries %>%
  ggplot() +
  geom_line(aes(x = year, 
                y = gdpPercap/10^3, 
                color = country)) +
  labs(title = "Gapminder",
       subtitle = "1957-2007",
       color = "País") +
  xlab("Ano") +
  ylab("PIB per capita \n (US$ mil)")
```

## Gráfico de dispersão

Gráficos de dispersão permitem visualizar a relação entre duas variáveis numéricas, o que nos permite visualizar possíveis correlações. Utilizaremos o dataset `gapminder2007` para ver de que forma o PIB per capita está relacionado à expectativa de vida nos diferentes países do mundo em 2007.

Desta vez poderemos mostrar de que forma o `ggplot2` pode mapear diferentes atributos das observações em um mesmo gráfico. Em nosso exemplo, cada ponto representa um país, cada cor um continente, e o tamanho dos pontos é dado por sua população.

```{r}
gapminder2007 %>%
  ggplot() +
  geom_point(aes(x = gdpPercap/10^3, 
                 y = lifeExp, 
                 color = continent, 
                 size = pop/10^6)) +
  labs(title = "Gapminder",
       subtitle = "2007",
       color = "Continente",
       size = "População \n (milhões de habitantes)") +
  xlab("PIB per capita \n (US$ mil)") +
  ylab("Expectativa de Vida \n (anos)")
```
